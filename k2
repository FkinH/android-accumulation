内存优化
看 DominatorTree，确定占用内存最多的实例
通过 GC root辅助分析内存占用的来源
通过 RetainHeapSize 量化的分析内存占用

UI卡顿
1. adb shell dumpsys SurfaceFlinger
获取最近127帧的数据，通过定期执行adb命令，获取帧数来计算出帧率FPS
2. adb shell dumpsys gfxinfo
详细包括每一帧绘制的Draw，Process，Execute三个过程的耗时，如果这三个时间总和超过16.6ms即认为是发生了卡顿。
3. UI线程的Looper打印的日志匹配，setMessageLogging
如果界面1秒钟刷新少于60次，即FPS小于60，用户就会产生卡顿感觉
4. Choreographer.FrameCallback
一次界面渲染会回调doFrame方法，如果两次doFrame之间的间隔大于16.6ms说明发生了卡顿。

插件化
1. 类加载
DexClassLoader的optimizedDirectory参数去加载外部的apk
PathClassLoader该参数为null，只能加载内部存储目录的Dex文件
双亲委托机制
ClassLoader调用loadClass方法加载类
DexPathList的loadClass会去遍历DexFile直到找到需要加载的类
ClassLoader时会传入主工程的ClassLoader作为父加载器，所以插件是可以直接可以通过类名引用主工程的类

2. 资源加载
插件apk的路径加入到AssetManager中，便能够实现对插件资源的访问
合并式：addAssetPath时加入所有插件和主工程的路径
独立式：各个插件只添加自己apk路径
替换了主工程context中LoadedApk的mResource对象
将新的Resource添加到主工程ActivityThread的mResourceManager中，并且根据Android版本做了不同处理
0xPPTTNNNN
修改aapt源码，编译期修改PP段。
修改resources.arsc文件，该文件列出了资源id到具体资源路径的映射。

3. 四大组件支持
3.1 ProxyActivity代理
ProxyActivity中需要重写getResouces，getAssets，getClassLoader方法返回插件的相应对象。生命周期函数以及和用户交互相关函数
PluginActivity中所有调用context的相关的方法,等都需要调用ProxyActivity的相应方法

缺点：
开发侵入性强；
启动模式需要管理activity栈

3.2 预埋StubActivity，hook系统启动Activity的过程
APP(INS)->AMS->APP
Instrumentation类的execStartActivity
跨进程的binder调用，进入到ActivityManagerService中，其内部会处理Activity栈
ApplicationThread将启动Activity2的信息通过H对象发送给主线程
主线程调用Instrumentation类的newActivity方法，其内通过ClassLoader创建Activity2

先在Manifest中预埋StubActivity，启动时将InstrumentationHook 内的Intent替换成StubActivity
隐式intent匹配到了插件中的Activity通过插件的ClassLoader反射创建插件Activity

okhttp


public static void quickSort(int[] data, int start, int end) {
    // 设置关键数据key为要排序数组的第一个元素，
    // 即第一趟排序后，key右边的数全部比key大，key左边的数全部比key小
    int key = data[start];
    // 设置数组左边的索引，往右移动比key大的数
    int i = start;
    // 设置数组右边的索引，往左移动比key小的数
    int j = end;
    // 如果左边索引比右边索引小，则还有数据没有排序
    while (i < j) {
        while (data[j] > key && j > i) {
            j--;
        }
        data[i] = data[j];
        
        while (data[i] < key && i < j) {
            i++;
        }
        data[j] = data[i];
    }
    // 此时 i==j
    data[i] = key;

    // 递归调用
    if (i - 1 > start) {
        // 递归调用，把key前面的完成排序
        quickSort(data, start, i - 1);
    }
    if (i + 1 < end) {
        // 递归调用，把key后面的完成排序
        quickSort(data, i + 1, end);
    }
}
