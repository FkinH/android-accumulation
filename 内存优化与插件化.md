### 内存优化
看 DominatorTree，确定占用内存最多的实例
通过 GC root辅助分析内存占用的来源
通过 RetainHeapSize 量化的分析内存占用

### UI卡顿
1. adb shell dumpsys SurfaceFlinger
获取最近127帧的数据，通过定期执行adb命令，获取帧数来计算出帧率FPS
2. adb shell dumpsys gfxinfo
详细包括每一帧绘制的Draw，Process，Execute三个过程的耗时，如果这三个时间总和超过16.6ms即认为是发生了卡顿。
3. UI线程的Looper打印的日志匹配，setMessageLogging
如果界面1秒钟刷新少于60次，即FPS小于60，用户就会产生卡顿感觉
4. Choreographer.FrameCallback
一次界面渲染会回调doFrame方法，如果两次doFrame之间的间隔大于16.6ms说明发生了卡顿。

### 插件化
1. 类加载
DexClassLoader的optimizedDirectory参数去加载外部的apk
PathClassLoader该参数为null，只能加载内部存储目录的Dex文件
双亲委托机制
ClassLoader调用loadClass方法加载类
DexPathList的loadClass会去遍历DexFile直到找到需要加载的类
ClassLoader时会传入主工程的ClassLoader作为父加载器，所以插件是可以直接可以通过类名引用主工程的类

2. 资源加载
插件apk的路径加入到AssetManager中，便能够实现对插件资源的访问
合并式：addAssetPath时加入所有插件和主工程的路径
独立式：各个插件只添加自己apk路径
替换了主工程context中LoadedApk的mResource对象
将新的Resource添加到主工程ActivityThread的mResourceManager中，并且根据Android版本做了不同处理
0xPPTTNNNN
修改aapt源码，编译期修改PP段。
修改resources.arsc文件，该文件列出了资源id到具体资源路径的映射。

3. 四大组件支持
3.1 ProxyActivity代理
ProxyActivity中需要重写getResouces，getAssets，getClassLoader方法返回插件的相应对象。生命周期函数以及和用户交互相关函数
PluginActivity中所有调用context的相关的方法,等都需要调用ProxyActivity的相应方法

缺点：
开发侵入性强；
启动模式需要管理activity栈

3.2 预埋StubActivity，hook系统启动Activity的过程
APP(INS)->AMS->APP
Instrumentation类的execStartActivity
跨进程的binder调用，进入到ActivityManagerService中，其内部会处理Activity栈
ApplicationThread将启动Activity2的信息通过H对象发送给主线程
主线程调用Instrumentation类的newActivity方法，其内通过ClassLoader创建Activity2

先在Manifest中预埋StubActivity，启动时将InstrumentationHook 内的Intent替换成StubActivity
隐式intent匹配到了插件中的Activity通过插件的ClassLoader反射创建插件Activity