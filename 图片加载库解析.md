### Glide
http://www.lightskystreet.com/2015/10/12/glide_source_analysis/
http://frodoking.github.io/2015/10/10/android-glide/

### Universal-image-loader

1. 多线程下载图片，图片可以来源于网络，文件系统，项目文件夹assets中以及drawable中等

2. 支持随意的配置ImageLoader，例如线程池，图片下载器，内存缓存策略，硬盘缓存策略，图片显示选项以及其他的一些配置

3. 支持图片的内存缓存，文件系统缓存或者SD卡缓存

4. 支持图片下载过程的监听

5. 根据控件(ImageView)的大小对Bitmap进行裁剪，减少Bitmap占用过多的内存

6. 较好的控制图片的加载过程，例如暂停图片加载，重新开始加载图片，一般使用在ListView,GridView中，滑动过程中暂停加载图片，停止滑动的时候去加载图片

7. 提供在较慢的网络下对图片进行加载

#### ImageLoaderConfiguration

是图片加载器ImageLoader的配置参数，使用了建造者模式

#### DisplayImageOptions

配置一些图片显示的选项，是否需要使用内存缓存，是否需要使用文件缓存，图片显示编码格式等等

#### ImageViewAware

该类主要是将ImageView进行一个包装，将ImageView的强引用变成弱引用，当内存不足的时候，可以更好的回收ImageView对象，还有就是获取ImageView的宽度和高度。这使得我们可以根据ImageView的宽高去对图片进行一个裁剪，减少内存的使用。

#### LoadAndDisplayImageTask

网络请求内核是`HttpURLConnection`

`isViewReused()` //避免加载不可见view的image

`tryLoadBitmap()` // 先从文件缓存中获取有没有Bitmap对象，如果没有在去从网络中获取，然后将bitmap保存在文件系统中


#### 内存策略

1. 只使用的是强引用缓存 

LruMemoryCache（这个类就是这个开源框架默认的内存缓存类，缓存的是bitmap的强引用，下面我会从源码上面分析这个类）

2. 使用强引用和弱引用相结合的缓存有

UsingFreqLimitedMemoryCache（如果缓存的图片总量超过限定值，先删除使用频率最小的bitmap）

LRULimitedMemoryCache（这个也是使用的lru算法，和LruMemoryCache不同的是，他缓存的是bitmap的弱引用）

FIFOLimitedMemoryCache（先进先出的缓存策略，当超过设定值，先删除最先加入缓存的bitmap）

LargestLimitedMemoryCache(当超过缓存限定值，先删除最大的bitmap对象)

LimitedAgeMemoryCache（当 bitmap加入缓存中的时间超过我们设定的值，将其删除）

3. 只使用弱引用缓存

WeakMemoryCache（这个类缓存bitmap的总大小没有限制，唯一不足的地方就是不稳定，缓存的图片容易被回收掉）

#### 硬盘策略

1. FileCountLimitedDiscCache（可以设定缓存图片的个数，当超过设定值，删除掉最先加入到硬盘的文件）

2. LimitedAgeDiscCache（设定文件存活的最长时间，当超过这个值，就删除该文件）

3. TotalSizeLimitedDiscCache（设定缓存bitmap的最大值，当超过这个值，删除最先加入到硬盘的文件）

4. UnlimitedDiscCache（这个缓存类没有任何的限制）